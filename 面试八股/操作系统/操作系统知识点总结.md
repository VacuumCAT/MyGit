## 操作系统知识点总结

**目录**
- [生产者消费者问题](#生产者-消费者问题)


### 生产者-消费者问题（小林coding图解操作系统/P137）
* 描述：
* **生产者**在生成数据之后，放在一个缓冲区中;
* **消费者**从缓冲区取出数据处理；
* 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区
  
* 使用一般信号量解决有限缓冲区生产者/消费者问题的方法：
```
/*program boundedbuffer*/
    const int sizeofbuffer = /*缓冲区大小*/
    semaphore s=1,n=0,e=sizeofbuffer;
    void producer()
    {
        while(true){
            produce();
            semWait(e);
            semwait(s);
            append();
            semSignal(s);
            semSignal(n);
        }
    }
    void consumer(){
        while(true){
            semWait(n);
            semWait(s);
            takee();
            semSignal(s);
            semSignal(e);
            consume();
        }
    }
    void main(){
        parbegin(producer,consumer);
    }

```

### 管程(P142)
*为什么使用管程？*  
——semWait和semSignal操作可能分布在整个程序中，很难看出信号量上的这些操作所产生的整体效果。

### 读者-写者问题(P150)
* 条件：
  1. 任意数量的读进程可以同时读这个文件
  2. 一次只有一个写进程可以写文件
  3. 若一个写进程正在写文件，则禁止任何读进程读文件

* 基于信号量的读者优先策略：
```
/* program readersandwriters*/
int readcount;
//x用来保证readcount被可靠更新
//wsem用来保证在有写进程写文件时，读进程不能读文件
semaphore x=1,wsem=1;

void reader()
{
    while(true){
        semWait(x);
        readcount++;
        //如果说第一个读进程卡在了semWait(wsem)这里
        //由于没有执行semSignal(x)，之后的读进程还开在semWait(x)，也就是无法读取文件
        //如果wsem=1，顺利读取，后面的读进程都可以直接进入
        if(readcount==1){
            semWait(wsem);
        }
        semSignal(x);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0){
            semSignal(wsem);//恢复wsem的值
        }
        semSignal(x);
    }
}

void writer()
{
    while(true){
        semWait(wsem);
        WIRTEUNIT();
        semSignal(wsem);
    }
}

void main{
    readcount=0;
    parbegin(reader,writer);
}
```

* 写者优先
  * 信号量rsem：至少有一个写进程准备访问数据区时，用于禁止所有的读进程
  * 变量writecount：控制rsem的设置
  * 信号量y：控制writecount的更新
  
```
/*program readersandwriters*/
int readcount,writecount;
semaphore x=1,y=1,z=1,wsem=1,rsem=1;

void reader()
{
    while(true){
        semWait(z);
            semWait(rsem);
                semWait(x);
                    readcount++;
                    if(readcount==1){
                        semWait(wsem);
                    }
                semSignal(x);
            semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
            readcount--;
            if(readcount==0){
                semSignal(wsem);
            }
        semSignal(x);
    }
}

void writer(){
    while(true){
        semWait(y);
            writecount++;
            if(writecount==1){
                semWait(rsem);
            }
        semSignal(y);
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
        semWait(y);
            writecount--;
            if(writecount==0){
                semSignal(rsem);
            }
        semSignal(y);
    }
}

void main(){
    readcount=writecount=0;
    parbegin(reader,writer);
}
```

* 公平策略（待更新）

### 哲学家就餐问题(P176)
* （书。待更新）
1. 基于信号量的解决方案：
2. 基于管程的解决方案：

* 小林coding
  * 方案1：  
  每个哲学家都先拿左边的叉子，再拿右边的叉子。  
  这样会导致死锁，即每个哲学家都拿到了左边的叉子，却无法永远拿到右边的叉子。
  * 方案2：  
  同时只允许一个哲学家拿叉子并吃饭  
  这样显然不会出现死锁，但效率太低了
  * 方案3：  
  让**偶数**编号的哲学家**先拿左边的叉子后拿右边的叉子**  
  让**奇数**编号的哲学家**先拿右边的叉子后拿左边的叉子**
  * 方案4： 
  用一个数组state记录每一位哲学家在进程、思考还是饥饿状态（正在试图拿叉子）。  
  那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态


### 并发：死锁和饥饿
1. 什么是死锁？
  在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。
  （表面上看）联合进程图有重叠
* 可重用资源：给系统设计施加关于资源请求顺序的约束、使用虚存  
* 可消耗资源
2. 死锁的条件  
   死锁有三个*必要条件*：  
   * 互斥：一次只有一个进程可以使用一个资源  
   * 占有且等待：当一个进程等待其他进程时，继续占有已经分配的资源 
   * 不可抢占：不能强行抢占其他进程已占有的资源  
   此外，要产生死锁，还需要*第四个条件*：  
   * 循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源  
3. **通常有三种处理死锁的方法：**
   * **死锁预防**：不允许死锁产生的三个必要条件成立  
     * 间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生。  
     * 直接死锁预防方法，即防止循环等待的发生。  
     * 对于这四个条件，进行具体分析：  
       互斥：一般来说，在列出的4个条件之中，第一个条件不可能禁止。若需要对资源进行互斥访问，则操作系统就必须支持互斥。某些资源，如文件，可能允许多个读访问，但只能允许互斥的写访问，此时若有多个进程请求写权限，则也可能发生死锁。  
       占有且等待：为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。这种方法由两个方面的低效性。首先，一个进程可能被阻塞很长时间，以等待满足其所有的资源请求。而实际上，只要有一部分资源，它就可以继续执行。其次，分配给一个进程的资源可能会在相当长的一段时间不会被该进程使用，且不能被其他进程使用。另一个问题是一个进程可能事先并不知道它所需要的所有资源。  
       不可抢占：预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。
       循环等待：循环等待条件可以通过定义资源类型的先行顺寻来预防。若一个进程已经分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源。  
       为证明这种策略的正确性，我们给每种资源类型指定一个下标。当i&lt;j时，资源Ri排在资源Rj前面。现在假设进程A和B死锁，原因是A获得Ri请求Rj，B获得Rj请求Ri，则这个条件不可能，因为这意味着i&lt;j且i&gt;j。

   * **死锁避免**：若此次分配可能产生死锁，就不满足该资源请求
     1. 进程启动拒绝(P171)  
     2. 资源分配拒绝(银行家算法)
   * **死锁检测**
     把所有能满足请求的进程的资源释放后标记，如果存在未标记的进程，说明存在死锁  
   
   1. 死锁预防
   简单来讲，死锁预防策略是试图设计一种系统来排除发生死锁的可能性。死锁预防方法分为两类。一类是间接死锁预防方法


### 进程和线程有什么区别？
- 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程有自己的独立地址空间，线程共享所属进程的地址空间；
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
- 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
- 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮
###  进程描述和控制
  进程的两个进本元素是**程序代码**和与代码关联的**数据集**。假设处理器开始执行这个程序代码，我们就把这个执行实体称为进程。进程执行的任意时刻，都可以由如下元素来表征：
  标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息  
