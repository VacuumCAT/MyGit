### 事务的概念和特性？
* 概念：事务（Transation）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束  
* 特性(ACID)：  
  * 原子性（Atomicity）:逻辑上是不可分割的操作单元，事务的所有操作要么提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）
  * 一致性（Consistency）:事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。  
  * 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（并发执行的事务之间不能相互影响）。
  * 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的
* 会出现哪些并发一致性问题？
  * 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。
  * 脏读（Dirty Read）：一个数据读取了被另一个事务修改，但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致
  * 不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）；
  * 幻读（Phantom Read）：当同一查询多次执行时，由于其他事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert/delete操作）；
* 数据库的四种隔离级别？
  * 未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其他事务也是可见的。会导致脏读、不可重复读、幻读；
  * 提交读（Read Commited）：一个事务只能看见已经提交的事务所作的改变，可避免脏读问题；
  * 可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果（MySQL的默认隔离级别）。可避免不可重复读。
  * 可串行化（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

* 什么是乐观锁和悲观锁？
  * 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其他事务读取或修改数据；应用于数据更新比较频繁的场景。
  * 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。  
    乐观锁的实现方式有：  
    * 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    * 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

* 常见的封锁类型？
  意向锁是InnoDB自动加的，不需要用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给设计数据集加排他锁（X）；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：共享锁：（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。其他session仍然可以查询记录，并也可以对该记录加share mode的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。排他锁（X）：SELECT * FROM table_name WHERE ...FOR UPDATE。其他session可以查询该记录，但不能对该记录加共享锁或排他锁，而是等待获得锁。
  * 排他锁(Exclusive Lock)/X锁：事务对数据上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。
  * 共享锁(Shared Lock)/S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。
  * 意向锁(Intention Locks)：
    * 一个事务在获得某个数据行对象的S锁之前，必须先获得整个表的IS锁或者更强的锁。
    * 一个事务在获得某个数据行对象的X锁之前，必须先获得整个表的IX锁；
    * IS/IX锁之间都是兼容的；
    * 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了。
  
* 封锁粒度的概念
  MySQL中提供了两种封锁粒度：行级锁以及表级锁。
  封锁粒度小：
  * 好处：锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高；
  * 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）

* 什么是三级封锁协议？
  * 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
  * 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
  * 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读的问题（避免了在事务结束之前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其他事务更新）
  
* 什么是两段锁协议？
  事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。
  可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同，事务遵循两段锁协议是保证可串行化调度的充分条件。

* 什么是MVCC？
  多版本并发控制（Multi-Version Concurrency Control,MVCC）, MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。
  * 创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会递增）；
  * 删除版本号：删除操作时的事务版本号；
  * 各种操作：
    * 插入操作时，记录创建版本号；
    * 删除操作时，记录删除版本号；
    * 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    * 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是再当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）
  通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC

* 快照读与当前读
  使用MVCC读取的是快照中的数据，这样可以减少加锁所带来的开销  
  ```
  select * from table ...;
  ```
  当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：
  ```
  select * from table where ? lock in share mode;
  select * from table where ? for update;
  insert;
  update;
  delete;
  ```
  在MySQL读取数据时可以按照是否使用一致性非锁定读来分为快照读和当前读：
  1、快照读：MySQL使用MVCC (Multiversion Concurrency Control)机制来保证被读取到数据的一致性，读取数据时不需要对数据进行加锁，且快照读不会被其他事物阻塞。
  2、当前读：也称锁定读(locking read),通过对读取到的数据(索引记录)加锁来保证数据一致性，当前读会对所有扫描到的索引记录进行加锁，无论该记录是否满足WHERE条件都会被加锁。

  在读提交和可重复读两种事务隔离级别下，普通的SELECT操作使用“快照读”，不会对数据加锁，也不会被事务阻塞。

  在读提交和可重复读两种事务隔离级别下，使用“当前读”的操作包括：
  1、SELECT LOCK IN SHARE MODE
  2、SELECT FOR UPDATE
  3、DELETE\UPDATE\INSERT INTO\REPLACE INTO

  在可重复读事务隔离级别下，“当前读”读取到的时数据库最新的数据，而“快照读”读取到的数据是事务中第一次建立ReadView时的数据+事务中修改的数据。

  作者：万物皆有序和公式
  链接：https://www.jianshu.com/p/46d5513f3238
  来源：简书
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

* 数据库的范式？
  * 第一范式（1NF，Normal Form）：属性不应该是可分的。举例：如果将“电话”作为一个属性（1列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话，如果将“移动电话”作为一个属性，就符合1NF；
  * 第二范式2NF：每个非主属性完全依赖于主属性集（候选键集）；
    * B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有荣誉（叫依赖补交完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
    * 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
    * 可以通过分解来满足2NF：将（学号，课程名，成绩）做成一张表；将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。
  * 第三范式3NF：在2NF的基础上，非主属性不传递依赖于主属性
    * 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
    * 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。必须先满足第二范式(2NF)，要求：表中的每一列只于主键直接相关而不是简介相关（表中的每一列都只能依赖于主键）；

* 不符合范式会出现哪些异常？
  * 冗余数据：某些同样的数据多次出现（如学生姓名）；
  * 修改一场：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；
  * 删除异常：删除一个信息，那么也会丢失其他信息（删除一个课程，丢失了一个学生的信息）；
  * 插入异常：无法插入（插入一个还没有课程信息的学生）

* 列举几种表连接方式？  
  * 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
    * 自然连接：只考虑属性相同的元组对；
    * 等值连接：给定条件进行查询
  * 外连接（Outer Join）：
    * 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
    * 右连接：和左连接相反；
    * 全外连接（Full Outer Join）：查询出左表和右表的所有数据，但是去除两表的重复数据
  * 交叉连接（Cross Join）:返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）

* 什么是存储过程？右哪些优缺点？
  存储过程是实现经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，具有输入输出参数）。
  优点：  
  * 预先编译，而不需要每次运行时编译，提高了数据库执行效率‘
  * 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量；
  * 具有可复用性，减少了