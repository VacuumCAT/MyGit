### 事务的概念和特性？
* 概念：事务（Transation）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束  
* 特性(ACID)：  
  * 原子性（Atomicity）:逻辑上是不可分割的操作单元，事务的所有操作要么提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）
  * 一致性（Consistency）:事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。  
  * 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的（并发执行的事务之间不能相互影响）。
  * 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的
* 会出现哪些并发一致性问题？
  * 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。
  * 脏读（Dirty Read）：一个数据读取了被另一个事务修改，但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致
  * 不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）；
  * 幻读（Phantom Read）：当同一查询多次执行时，由于其他事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert/delete操作）；
* 数据库的四种隔离级别？
  * 未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其他事务也是可见的。会导致脏读、不可重复读、幻读；
  * 提交读（Read Commited）：一个事务只能看见已经提交的事务所作的改变，可避免脏读问题；
  * 可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果（MySQL的默认隔离级别）。可避免不可重复读。
  * 可串行化（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

* 什么是乐观锁和悲观锁？
  * 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其他事务读取或修改数据；应用于数据更新比较频繁的场景。
  * 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。  
    乐观锁的实现方式有：  
    * 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
    * 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。

* 常见的封锁类型？
  意向锁是InnoDB自动加的，不需要用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给设计数据集加排他锁（X）；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：共享锁：（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。其他session仍然可以查询记录，并也可以对该记录加share mode的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。排他锁（X）：SELECT * FROM table_name WHERE ...FOR UPDATE。其他session可以查询该记录，但不能对该记录加共享锁或排他锁，而是等待获得锁。
  * 排他锁(Exclusive Lock)/X锁：事务对数据上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。
  * 共享锁(Shared Lock)/S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁。
  * 意向锁(Intention Locks)：
    * 一个事务在获得某个数据行对象的S锁之前，必须先获得整个表的IS锁或者更强的锁。
    * 一个事务在获得某个数据行对象的X锁之前，必须先获得整个表的IX锁；
    * IS/IX锁之间都是兼容的；
    * 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了。
  
* 封锁粒度的概念
  MySQL中提供了两种封锁粒度：行级锁以及表级锁。
  封锁粒度小：
  * 好处：锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高；
  * 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）

* 什么是三级封锁协议？
  * 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
  * 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
  * 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读的问题（避免了在事务结束之前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其他事务更新）
  
* 什么是两段锁协议？
  事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。
  可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同，事务遵循两段锁协议是保证可串行化调度的充分条件。

* 什么是MVCC？
  多版本并发控制（Multi-Version Concurrency Control,MVCC）, MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。
  * 创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会递增）；
  * 删除版本号：删除操作时的事务版本号；
  * 各种操作：
    * 插入操作时，记录创建版本号；
    * 删除操作时，记录删除版本号；
    * 更新操作时，先记录删除版本号，再新增一行记录创建版本号；
    * 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是再当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）
  通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC

* 快照读与当前读
  使用MVCC读取的是快照中的数据，这样可以减少加锁所带来的开销  
  ```
  select * from table ...;
  ```
  当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：
  ```
  select * from table where ? lock in share mode;
  select * from table where ? for update;
  insert;
  update;
  delete;
  ```
  在MySQL读取数据时可以按照是否使用一致性非锁定读来分为快照读和当前读：
  1、快照读：MySQL使用MVCC (Multiversion Concurrency Control)机制来保证被读取到数据的一致性，读取数据时不需要对数据进行加锁，且快照读不会被其他事物阻塞。
  2、当前读：也称锁定读(locking read),通过对读取到的数据(索引记录)加锁来保证数据一致性，当前读会对所有扫描到的索引记录进行加锁，无论该记录是否满足WHERE条件都会被加锁。

  在读提交和可重复读两种事务隔离级别下，普通的SELECT操作使用“快照读”，不会对数据加锁，也不会被事务阻塞。

  在读提交和可重复读两种事务隔离级别下，使用“当前读”的操作包括：
  1、SELECT LOCK IN SHARE MODE
  2、SELECT FOR UPDATE
  3、DELETE\UPDATE\INSERT INTO\REPLACE INTO

  在可重复读事务隔离级别下，“当前读”读取到的时数据库最新的数据，而“快照读”读取到的数据是事务中第一次建立ReadView时的数据+事务中修改的数据。

  作者：万物皆有序和公式
  链接：https://www.jianshu.com/p/46d5513f3238
  来源：简书
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

* 数据库的范式？
  * 第一范式（1NF，Normal Form）：属性不应该是可分的。举例：如果将“电话”作为一个属性（1列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话，如果将“移动电话”作为一个属性，就符合1NF；
  * 第二范式2NF：每个非主属性完全依赖于主属性集（候选键集）；
    * B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有荣誉（叫依赖补交完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
    * 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
    * 可以通过分解来满足2NF：将（学号，课程名，成绩）做成一张表；将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情。
  * 第三范式3NF：在2NF的基础上，非主属性不传递依赖于主属性
    * 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
    * 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。必须先满足第二范式(2NF)，要求：表中的每一列只于主键直接相关而不是简介相关（表中的每一列都只能依赖于主键）；

* 不符合范式会出现哪些异常？
  * 冗余数据：某些同样的数据多次出现（如学生姓名）；
  * 修改一场：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；
  * 删除异常：删除一个信息，那么也会丢失其他信息（删除一个课程，丢失了一个学生的信息）；
  * 插入异常：无法插入（插入一个还没有课程信息的学生）

* 列举几种表连接方式？  
  * 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集
    * 自然连接：只考虑属性相同的元组对；
    * 等值连接：给定条件进行查询
  * 外连接（Outer Join）：
    * 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；
    * 右连接：和左连接相反；
    * 全外连接（Full Outer Join）：查询出左表和右表的所有数据，但是去除两表的重复数据
  * 交叉连接（Cross Join）:返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）

* 什么是存储过程？右哪些优缺点？
  存储过程是实现经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，具有输入输出参数）。
  优点：  
  * 预先编译，而不需要每次运行时编译，提高了数据库执行效率‘
  * 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量；
  * 具有可复用性，减少了数据库开发的工作量；
  * 安全性高，可以让没有权限的用户通过存储过程简介操作数据库；
  * 更易于维护；  
  缺点：
  * 可移植性差，存储过程将应用程序绑定到了数据库上；
  * 开发调试复杂，没有好的IDE；
  * 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用；

* Drop/Delete/Truncate的区别？
  * DELETE用来删除表的全部或者部分数据，执行delete之后，用户需要提交之后才会执行，会触发表上的delete触发器（包含一个OLD的虚拟表，可以只读访问被删除的数据），delete之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据。
  * Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器。操作比delete快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
  * Drop命令从数据库中删除表，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器。

* 什么是触发器？
  触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，勇于保证数据完整性（比如可检验或转换数据）。

* 有哪些约束类型？
  约束（Constraint）类型：主键（Primary Key）约束、唯一约束（Unique）、检查约束、非空约束、外键（Foreign）约束。

* 什么是视图？什么是游标？  
  * 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；对视图的改动会影响原表的数据。
  好处：
  * 通过只给用户访问视图的权限，保证数据的安全性；
  * 简化复杂的SQL操作，隐藏数据的复杂性。
  * 游标（Cursor）：用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改人一行中的数据。主要用于交互式应用。

* 数据库分类：

* 关系型和非关系型数据库的区别（各自的优点）：
  * 关系型数据库是简单的表结构，优点：易于维护，使用方便，直接用sql语句进行查询，支持复杂的多表的连接查询；缺点：读写性能差，尤其是面对海量数据的高效率读写；固定的表结构，灵活性差；高并发读写需求，面临硬盘I/O的瓶颈
  * 非关系型数据库：（包括四种：键值存储数据库Redis，列存储数据库HBase，文档数据库MongoDB CoachDB，图形数据库Neo4j）优点：格式灵活，支持以上四种格式；速度快，扩展性好，容易部署；缺点：不支持事务，不支持SQL，不利于复杂的查询  
  
* 数据库的索引类型
  * 唯一索引：每一个索引对应唯一的数据记录
  * 主键索引：以主键为索引
  * 聚集索引：索引的顺序和数据存储的物理顺序是相同的
  
* 聚集索引和非聚集索引的区别：
  * 聚集索引：表数据按照索引的顺序存储，索引的顺序和表中记录的物理顺序一致。叶子结点存储了真实的数据行，不再有另外单独的数据页。
  * 非聚集索引：索引的逻辑顺序和数据存储的物理顺序无关。

* 唯一性索引和主码索引的区别
  * 主键索引只能创建一个，唯一索引可以创建多个
  * 主键索引列不能是空值，唯一索引列可以是空值
  * 主键索引严格来讲就是表的主键，是一种约束；唯一索引是一种索引，它是一种数据结构，二者有本质的差别
  * 主键索引可以作为其它表的外键，而唯一索引不可以
  * 主键一定会创建一个唯一索引，但有唯一索引的列不一定是主键

* 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）？
  * 索引的优缺点：  
    优点：加快表的查询速度，加快表之间的连接，唯一索引保证表中的每一行数据的唯一性，在进行分组和排序查询时，减少查询中分组和排序的时间，借助索引可以提高查询的速度；  
    缺点：需要占额外的存储空间；索引的维护和创建需要花费一定的时间；当表发生改变时，同时也要更新索引
  * 什么时候需要创建索引？
    主键自动建立唯一索引，频繁作为查询条件的字段应该建立索引，查询中排序字段的创建会大大提高索引速度，查询中统计或者分组的字段
  * 什么时候不能使用索引？
    频繁进行更新的字段，因为更新字段时不单单需要更新记录，还会更新索引，保存索引文件  
    where条件中用不到的字段  
    记录太少的表  
    经常进行增删改的表 
    数据重复且分布平均的字段  

* 索引的底层实现（B+树，为何不采用红黑树，B树）
  * 红黑树也可以作为索引的底层实现，但是一般不用红黑树，因为索引是以索引文件的形式存储在磁盘中，访问磁盘需要I/O操作，因此I/O操作的次数是衡量索引底层实现好坏的标准。  
  * B-树原理：树的高度为h，节点的度为d，B-树用了磁盘局部性原理，将一个节点的大小设置为一个页，这样每个节点只需要一次I/O就可以完全读入，B-树的深度决定了I/O的次数，最多进行h-1次I/O操作（根节点常驻内存）。然而红黑树的高度比B-树的高度要深得多，而且逻辑上相邻的节点可能在物理上很远，无法利用磁盘的局部性原理。因此红黑树的性能比B-数要差很多。
  * B+树：B+树更适合外存索引。B+树去掉了内节点去掉了data域，因此有更大的出度，有更好的性能。而且按关键字进行查找，不经过分支节点，按叶子节点的指针就能够访问所有的节点。
  https://github.com/wolverinn/Iridescent/blob/master/Data%20Structure.md#b%E6%A0%91
* B树和B+树的具体实现：  
  * B树和B+树都属于多录平衡查找树，是为了解决查询效率低的问题而实现的，B+树是B树的眼神
  * 度数：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。
  * 阶数（Order）：阶定义为一个节点的子节点数目的最大值（自带最大值属性）。
  * B树：B树的阶数为m  
    每个节点最多有m棵子树（最多有m-1个关键字）；所有非叶子节点除根节点外最少有m/2（取上界）棵子树（最少有m/2-1个关键字）。根节点至少有一个关键字  
    一个节点中的关键字按非降序排列  
    每个节点的关键字对应其子树的范围
    所有的叶子结点有相同的深度（h<=logd(n+1)/2）
  * B+树：B+树的阶数为m  
    除根节点外的内部节点，每个节点最多有m个关键字，最少有m/2个关键字，每个关键字对应一个子树；根节点要么没有子树，要么至少两颗子树  
    所有叶子节点包含了全部关键字，以及这些关键字指向文件的指针，所有叶子结点按关键字大小排序，相邻叶子结点顺序链接，相当于构成一个顺序链表，所有叶子结点在同一层；
    分支节点中的关键字对应子树中关键字的最大值
  * 二者的区别:  
    B+树每个节点的关键字的个数和其子树的个数相等，而B树关键字的个数比子树的个数少1.
    B+树所有的关键字及指针都存储到叶子节点中，内部节点相当于索引，B树指向文件的关键字在内部节点中。
    B+树在搜索过程中，如果内部节点与当前关键字匹配，则继续搜索，直到搜索到根节点。

* 索引最左前缀问题  
  * 联合索引：以一定顺序引用多个列，这种索引叫联合索引，一个联合索引是一个有序元组。索引的最左前缀匹配是指在建立联合索引时，索引的任何前缀都会勇于查询，例如：联合索引（col1，col2，col3）这个联合索引的所有前缀就是（col1），（col1，col2），（col1，col2，col3），包含这些列的查询都会启用索引查询；但是不在最左前缀里的列，即使包含在联合索引中也不会启用索引。
  * 最左前缀匹配原则：一直向右匹配，直到遇到范围查询（>,<,between,like）就停止匹配。比如a=1 and b=2 and c>3 and d=4如果建立（a，b，c，d）顺序的索引，d是用不到索引的，如果建立（a，b，d，c）的索引则都可以用到，a，b。d的顺序可以任意调整。

* Mysql的优化（结构优化，查询优化），MySQL慢查询优化
  索引策略属于结构优化的范畴  
  **索引优化**：  
  索引优化这里不得不提到联合索引，联合索引是以一定的顺序引用多个列，在查询的过程中会使用最左前缀匹配的索引。
  1. 当全列匹配时，不用考虑where的查询条件中列的顺序，查询优化器会自动调整其顺序，以使用最适合的索引；
  2. 最左前缀匹配：当匹配索引左面的一列或者几列时，会用到索引，但只会用到一部分；
  3. 查询条件中用到了索引中列的精确匹配中的一部分，中间某个条件未提供，如果中间这个条件对应的值少，可以考虑用IN来填补这个坑，从而形成最左前缀（隔离列的优化方式）；否则，可以建立辅助索引；
  4. 查询条件中没有制定索引的第一列，没有办法用到索引；
  5. 查询条件中包含匹配某列的前缀字符串，当该条件（也就是含有通配符的条件%）不出现在开头时，可以用该条件所在的列及其之前的列作为索引，查询条件不同，用到的索引的前缀的个数也不同
  6. 查询条件中包含范围时，包含范围的列可以作为索引，但最多只能用于一个范围列，注意BETWEEN并不代表范围，相当于关键字IN
  7. 查询条件中含有函数或者表达式的列，该列不会作为索引  
  **索引的底层实现的优化**：
  MySQL的默认的数据库引擎是innodb，innodb使用默认自增的主键作为索引，这样每次插入索引时是从右边扩展的，避免了B+树节点的频繁的分裂和合并，如果采用随机主键，会使得数据随机插入，效率低。
  **为什么使用select * from table会使得查询效率低？**
  select *语句取出表中的所有字段，会解析更多的对象，字段，权限，属性等，无论该字段的数据对调用的程序是否有用，这会造成服务器资源的浪费，导致优化和效率问题，对服务器的性能产生一定的影响
  **总结**：
  * 索引方面：为了避免全表扫描，首先考虑在where及order by涉及的列上建立索引；如果该索引是复合索引，必须使用该索引中的第一个字段作为条件时，才能用到该索引，并尽可能的让，并尽可能的让索引顺序和字段顺序一致
  * sql语句编写方面：在where子句中，避免对字段进行null值判断，避免使用!=,<,>操作符，避免使用or来建立链接条件，慎用in和not in，慎用like'%abc%'，避免对字段进行表达式操作和函数操作，会导致引擎放弃索引而进行全表扫描；用exists代替in是一个提高查询效率的方法；任何地方都不要使用select * from t，用具体的字段代替“*”，不要返回用不到的字段
  * 设计表时，尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这样会降低查询和链接的效率，增加存储开销，因为引擎处理查询和连接时会诸葛比较字符串中的每一个字符，对于数字型而言只比较一次就够了；尽量使用varchar代替char，因为变长字段存储空间小，可以节省内存空间，在查询时，一个较小的字段搜索效率高；避免频繁创建表、删除表，减少系统的表资源消耗。

* 分布式事务
  分布式事务：事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上，分布式事务是为了保证数据库的数据一致性。
  * 强一致性：  
  任何一次都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任何时刻，所有节点的数据是一致的。
  * 弱一致性：数据更新后，能容忍后续的访问只能访问到部分或者全部访问不到。
  * 最终一致性：不能保证在任意时刻节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，在一段时间后，节点间的数据会最终到达一致状态。

* CAP（Consistency，Availability，Partition torlence）原则：
  * 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否具有同样的值。（所有节点访问到同一份最新数据的副本）
  * 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
  * 分区容错性（Partition torlence）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就有意味着发生了分区的情况，就必须在C和A之间做出选择
  CAP原则：要么是AP，要么是CP，要么是CA，但是不存在CAP。

* BASE（Base Avaliable Soft State Eventual Consistency）理论：
  BASE理论指的是基本可用Basically Avaliable，软状态Soft State，最终一致性Eventual Consistency，核心思想：即使无法做到强一致性，但应该采用适合的方式保证一致性。
  * BA（Base Avaliable）：基本可用，分布式系统在出现故障时，允许损失部分可用性，即保证核心可用
  * S（Soft State）：软状态，允许系统存在中间状态，而中间状态不会影响系统的可用性
  * E（Eventual Consistency）：最终一致性，系统中所有的副本经过一定的时间后，最终能够达到一致的状态
  
* 柔性事务：不同于ACID的刚性事务，在分布式场景下，基于BASE理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样，但是都不满足的话，是不可能做柔性事务的。