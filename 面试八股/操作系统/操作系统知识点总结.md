# 操作系统知识点总结

**目录**
- [操作系统知识点总结](#操作系统知识点总结)
  - [背景知识](#背景知识)
  - [进程](#进程)
    - [进程描述与控制](#进程描述与控制)
        - [进程拥有的资源](#进程拥有的资源)
        - [进程创建](#进程创建)
        - [进程切换](#进程切换)
    - [线程](#线程)
    - [进程和线程有什么区别？](#进程和线程有什么区别)
        - [同一进程中的线程可以共享哪些数据？](#同一进程中的线程可以共享哪些数据)
        - [线程独占哪些资源？](#线程独占哪些资源)
    - [进程描述和控制](#进程描述和控制)
    - [生产者-消费者问题（小林coding图解操作系统/P137）](#生产者-消费者问题小林coding图解操作系统p137)
  - [内存](#内存)
  - [调度](#调度)
    - [生产者-消费者问题（小林coding图解操作系统/P137）](#生产者-消费者问题小林coding图解操作系统p137-1)
  - [I/O与文件](#io与文件)
    - [管程(P142)](#管程p142)
    - [读者-写者问题(P150)](#读者-写者问题p150)
    - [哲学家就餐问题(P176)](#哲学家就餐问题p176)
    - [并发：死锁和饥饿](#并发死锁和饥饿)
    - [进程间通信有哪些方式？](#进程间通信有哪些方式)
        - [临界区的概念？](#临界区的概念)
        - [同步与互斥的概念？](#同步与互斥的概念)
        - [并发、并行、异步的区别？](#并发并行异步的区别)
    - [进程有哪几种状态？](#进程有哪几种状态)
    - [进程调度策略有哪些？](#进程调度策略有哪些)
        - [什么叫优先级反转？如何解决？](#什么叫优先级反转如何解决)
    - [什么是僵尸进程？](#什么是僵尸进程)
        - [什么是孤儿进程？](#什么是孤儿进程)
    - [线程同步有哪些方式？](#线程同步有哪些方式)
        - [互斥量和临界区有什么区别？](#互斥量和临界区有什么区别)
    - [什么是协程？](#什么是协程)
        - [协程多与线程进行比较？](#协程多与线程进行比较)
    - [什么是IO多路复用？怎么实现？](#什么是io多路复用怎么实现)
    - [select/poll/epoll三者的区别？](#selectpollepoll三者的区别)
        - [什么时候使用select/poll，什么时候使用epoll？](#什么时候使用selectpoll什么时候使用epoll)
        - [什么是文件描述符？](#什么是文件描述符)
        - [什么是水平触发？什么是边缘触发？](#什么是水平触发什么是边缘触发)
        - [有哪些常见的IO模型？](#有哪些常见的io模型)
    - [什么是用户态和内核态？](#什么是用户态和内核态)
        - [为什么要分用户态和内核态？](#为什么要分用户态和内核态)
        - [如何从用户态切换到内核态？](#如何从用户态切换到内核态)
    - [常见锁的种类](#常见锁的种类)
    - [调度算法](#调度算法)
        - [进程调度算法](#进程调度算法)
        - [内存页面置换算法](#内存页面置换算法)
        - [磁盘调度算法](#磁盘调度算法)
  - [文件系统](#文件系统)
  - [设备管理](#设备管理)
    - [分页和分段有什么区别？](#分页和分段有什么区别)
    - [什么是虚拟内存？](#什么是虚拟内存)
        - [如何进行地址空间到物理内存的映射？](#如何进行地址空间到物理内存的映射)
    - [有哪些页面置换算法？](#有哪些页面置换算法)
        - [局部性原理](#局部性原理)
        - [什么是颠簸现象](#什么是颠簸现象)

## 背景知识

## 进程
### 进程描述与控制
##### 进程拥有的资源
1. 标识符：与进程相关的唯一标识符，用来区分其他进程。
2. 状态：若进程正在执行，则进程处于运行态。
3. 优先级：相对于其他进程的优先顺序。
4. 程序计数器：程序中即将执行的下一条指令的地址。
5. 内存指针：包括程序代码和进程相关的数据指针，以及其与其他进程共享内存块的指针。
6. 上下文数据：进程执行时处理器的寄存器中的数据。
7. I/O状态信息：包括显式I/O请求、分配给进程的I/O设备和被进程使用的文件列表等。
8. 记账信息：包括处理器时间综合、使用的时钟数综合、时间限制、记帐号等。
以上信息存放在被称为**进程控制块(process control block)**的数据结构中，控制块由操作系统创建和管理。
##### 进程创建
1. 为新进程分配一个唯一的进程标识符。
2. 为进程分配空间。
3. 初始化进程控制块。
4. 设置正确的链接。
5. 创建或补充其他数据结构。

**fork函数**：
一个进程发出一个fork请求时，操作系统执行如下功能：
1. 在进程表中为新进程分配一个空项。
2. 为子进程分配一个唯一进程标识符。
3. 复制父进程的进程映像，但共享内存除外。
4. 增加父进程所拥有文件的计数器，反应另一个进程现在也拥有这些文件的事实。
5. 将子进程置为就绪态。
6. 将子进程的ID号返回给父进程，将0值返回给子进程。
所有这些工作都在父进程的内核模式下完成。内核完成这些功能后，可继续分派器例程工作一部分的如下三种操作之一：
* 停留在父进程中。控制权返回到用户模式下父进程调用fork的位置。
* 处理器控制权交给子进程。子进程开始执行代码，执行点与父进程相同，即在fork调用的返回处。
* 控制权转交给另一个进程。父进程和子进程都置于就绪态。

##### 进程切换
1. 何时切换进程？
   * 中断
   * 陷阱
   * 系统调用
2. 完整步骤：
   1. 保存处理器的上下文，包括程序计数器和其他寄存器。
   2. 更新当前处于运行态进程的进程控制块，包括把进程的状态改变为另一状态（就绪态、阻塞态、就绪/挂起态或推出态）。还须更新其他相关的字段，包括退出运行态的原因和记账信息。
   3. 把该进程的进程控制块移到相应的队列（就绪、在事件i处阻塞、就绪/挂起）。
   4. 选择另一个进程执行。
   5. 更新所选进程的进程控制块，包括把进程的状态改为运行态。
   6. 更新内存管理数据结构。是否需要更新取决于管理地址转换的方式。
   7. 载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。

### 线程

### 进程和线程有什么区别？
- 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程有自己的独立地址空间，线程共享所属进程的地址空间；
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
- 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
- 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮

##### 同一进程中的线程可以共享哪些数据？
- 进程代码段
- 进程的公有数据（全局变量、静态变量...）
- 进程打开的文件描述符
- 进程的当前目录
- 信号处理器/信号处理函数：对收到的信号的处理方式
- 进程ID与进程组ID

##### 线程独占哪些资源？
- 线程ID
- 一组寄存器的值
- 线程自身的栈（堆是共享的）
- 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；
- 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）
###  进程描述和控制
  进程的两个进本元素是**程序代码**和与代码关联的**数据集**。假设处理器开始执行这个程序代码，我们就把这个执行实体称为进程。进程执行的任意时刻，都可以由如下元素来表征：
  标识符、状态、优先级、程序计数器、内存指针、上下文数据、I/O状态信息、记账信息  
### 生产者-消费者问题（小林coding图解操作系统/P137）
* 描述：
* **生产者**在生成数据之后，放在一个缓冲区中;
* **消费者**从缓冲区取出数据处理；
* 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区
  
* 使用一般信号量解决有限缓冲区生产者/消费者问题的方法：
```
/*program boundedbuffer*/
    const int sizeofbuffer = /*缓冲区大小*/
    semaphore s=1,n=0,e=sizeofbuffer;
    void producer()
    {
        while(true){
            produce();
            semWait(e);
            semwait(s);
            append();
            semSignal(s);
            semSignal(n);
        }
    }
    void consumer(){
        while(true){
            semWait(n);
            semWait(s);
            takee();
            semSignal(s);
            semSignal(e);
            consume();
        }
    }
    void main(){
        parbegin(producer,consumer);
    }

```
## 内存

## 调度
### 生产者-消费者问题（小林coding图解操作系统/P137）
* 描述：
* **生产者**在生成数据之后，放在一个缓冲区中;
* **消费者**从缓冲区取出数据处理；
* 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区
  
* 使用一般信号量解决有限缓冲区生产者/消费者问题的方法：
```
/*program boundedbuffer*/
    const int sizeofbuffer = /*缓冲区大小*/
    semaphore s=1,n=0,e=sizeofbuffer;
    void producer()
    {
        while(true){
            produce();
            semWait(e);
            semwait(s);
            append();
            semSignal(s);
            semSignal(n);
        }
    }
    void consumer(){
        while(true){
            semWait(n);
            semWait(s);
            takee();
            semSignal(s);
            semSignal(e);
            consume();
        }
    }
    void main(){
        parbegin(producer,consumer);
    }

```
## I/O与文件


### 管程(P142)
*为什么使用管程？*  
——semWait和semSignal操作可能分布在整个程序中，很难看出信号量上的这些操作所产生的整体效果。  
管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。

当一个进程试图进入管程时，在**入口等待队列**等待。若P进程唤醒了Q进程，则Q进程先执行，P在**紧急等待队列**中等待。（**HOARE管程**）

wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（**HOARE管程**）

**MESA管程**：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换

### 读者-写者问题(P150)
* 条件：
  1. 任意数量的读进程可以同时读这个文件
  2. 一次只有一个写进程可以写文件
  3. 若一个写进程正在写文件，则禁止任何读进程读文件

* 基于信号量的读者优先策略：
```
/* program readersandwriters*/
int readcount;
//x用来保证readcount被可靠更新
//wsem用来保证在有写进程写文件时，读进程不能读文件
semaphore x=1,wsem=1;

void reader()
{
    while(true){
        semWait(x);
        readcount++;
        //如果说第一个读进程卡在了semWait(wsem)这里
        //由于没有执行semSignal(x)，之后的读进程还开在semWait(x)，也就是无法读取文件
        //如果wsem=1，顺利读取，后面的读进程都可以直接进入
        if(readcount==1){
            semWait(wsem);
        }
        semSignal(x);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0){
            semSignal(wsem);//恢复wsem的值
        }
        semSignal(x);
    }
}

void writer()
{
    while(true){
        semWait(wsem);
        WIRTEUNIT();
        semSignal(wsem);
    }
}

void main{
    readcount=0;
    parbegin(reader,writer);
}
```

* 写者优先
  * 信号量rsem：至少有一个写进程准备访问数据区时，用于禁止所有的读进程
  * 变量writecount：控制rsem的设置
  * 信号量y：控制writecount的更新
  
```
/*program readersandwriters*/
int readcount,writecount;
semaphore x=1,y=1,z=1,wsem=1,rsem=1;

void reader()
{
    while(true){
        semWait(z);
            semWait(rsem);
                semWait(x);
                    readcount++;
                    if(readcount==1){
                        semWait(wsem);
                    }
                semSignal(x);
            semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
            readcount--;
            if(readcount==0){
                semSignal(wsem);
            }
        semSignal(x);
    }
}

void writer(){
    while(true){
        semWait(y);
            writecount++;
            if(writecount==1){
                semWait(rsem);
            }
        semSignal(y);
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
        semWait(y);
            writecount--;
            if(writecount==0){
                semSignal(rsem);
            }
        semSignal(y);
    }
}

void main(){
    readcount=writecount=0;
    parbegin(reader,writer);
}
```

* 公平策略（待更新）

### 哲学家就餐问题(P176)
* （书。待更新）
1. 基于信号量的解决方案：
2. 基于管程的解决方案：

* 小林coding
  * 方案1：  
  每个哲学家都先拿左边的叉子，再拿右边的叉子。  
  这样会导致死锁，即每个哲学家都拿到了左边的叉子，却无法永远拿到右边的叉子。
  * 方案2：  
  同时只允许一个哲学家拿叉子并吃饭  
  这样显然不会出现死锁，但效率太低了
  * 方案3：  
  让**偶数**编号的哲学家**先拿左边的叉子后拿右边的叉子**  
  让**奇数**编号的哲学家**先拿右边的叉子后拿左边的叉子**
  * 方案4： 
  用一个数组state记录每一位哲学家在进程、思考还是饥饿状态（正在试图拿叉子）。  
  那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态


### 并发：死锁和饥饿
1. 什么是死锁？
  在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。
  （表面上看）联合进程图有重叠
* 可重用资源：给系统设计施加关于资源请求顺序的约束、使用虚存  
* 可消耗资源
2. 死锁的条件  
   死锁有三个*必要条件*：  
   * 互斥：一次只有一个进程可以使用一个资源  
   * 占有且等待：当一个进程等待其他进程时，继续占有已经分配的资源 
   * 不可抢占：不能强行抢占其他进程已占有的资源  
   此外，要产生死锁，还需要*第四个条件*：  
   * 循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源  
3. **通常有三种处理死锁的方法：**
   * **死锁预防**：不允许死锁产生的三个必要条件成立  
     * 间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生。  
     * 直接死锁预防方法，即防止循环等待的发生。  
     * 对于这四个条件，进行具体分析：  
       互斥：一般来说，在列出的4个条件之中，第一个条件不可能禁止。若需要对资源进行互斥访问，则操作系统就必须支持互斥。某些资源，如文件，可能允许多个读访问，但只能允许互斥的写访问，此时若有多个进程请求写权限，则也可能发生死锁。  
       占有且等待：为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。这种方法由两个方面的低效性。首先，一个进程可能被阻塞很长时间，以等待满足其所有的资源请求。而实际上，只要有一部分资源，它就可以继续执行。其次，分配给一个进程的资源可能会在相当长的一段时间不会被该进程使用，且不能被其他进程使用。另一个问题是一个进程可能事先并不知道它所需要的所有资源。  
       不可抢占：预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。
       循环等待：循环等待条件可以通过定义资源类型的先行顺寻来预防。若一个进程已经分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源。  
       为证明这种策略的正确性，我们给每种资源类型指定一个下标。当i&lt;j时，资源Ri排在资源Rj前面。现在假设进程A和B死锁，原因是A获得Ri请求Rj，B获得Rj请求Ri，则这个条件不可能，因为这意味着i&lt;j且i&gt;j。

   * **死锁避免**：若此次分配可能产生死锁，就不满足该资源请求
     1. 进程启动拒绝(P171)  
     2. 资源分配拒绝(银行家算法)
   * **死锁检测**
     把所有能满足请求的进程的资源释放后标记，如果存在未标记的进程，说明存在死锁  
   
   1. 死锁预防
   简单来讲，死锁预防策略是试图设计一种系统来排除发生死锁的可能性。死锁预防方法分为两类。一类是间接死锁预防方法




### 进程间通信有哪些方式？

1. 管道(Pipe)
   - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
   - 一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；
   - 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
2. 命名管道
3. 消息队列
4. 信号(Signal)
5. 共享内存
6. 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态
7. 套接字(Socket)

##### 临界区的概念？
各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段

##### 同步与互斥的概念？
- 同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区

##### 并发、并行、异步的区别？
并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；

多线程：并发运行的一段代码。是实现异步的手段

并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的

异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事

### 进程有哪几种状态？
- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行

### 进程调度策略有哪些？
1. **批处理系统**：
  * 先来先服务 first-come first-serverd（FCFS）
    按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；
    对短进程不利，对IO密集型进程不利。
  * 最短作业优先 shortest job first（SJF）
    按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；
    对短进程提供好的响应时间，对长进程不利。
  * 最短剩余时间优先 shortest remaining time next（SRTN）
    按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；
    可能导致饥饿问题，对长进程不利。
  * 最高响应比优先 Highest Response Ratio Next（HRRN）
    响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。
2. **交互式系统**  
  * 时间片轮转 Round Robin
  将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；
  若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。
  * 优先级调度算法
  为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
  * 多级反馈队列调度算法 Multilevel Feedback Queue
  设置多个就绪队列1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。
  抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。


##### 什么叫优先级反转？如何解决？
高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。
解决方法：
- 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。
- 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。

### 什么是僵尸进程？
一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。

危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。

以下情况不会产生僵尸进程：
- 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。
- 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入```WNOHANG```(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；
- 子进程结束时，系统会产生```SIGCHLD```(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；
- 也可以用```signal(SIGCLD, SIG_IGN)```(signal-ignore)通知内核，表示忽略```SIGCHLD```信号，那么子进程结束后，内核会进行回收。

##### 什么是孤儿进程？
一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。

### 线程同步有哪些方式？
> 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。

- **互斥量** Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；
- **信号量** Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了**最大资源计数**和**当前可用资源计数**，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过```ReleaseSemaphore```函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；
- **事件** Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒**一个**等待中的线程，然后自动恢复为未激发状态。
- **临界区** Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。

##### 互斥量和临界区有什么区别？
互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。

### 什么是协程？
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

##### 协程多与线程进行比较？
1. 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2. 线程进程都是同步机制，而协程则是异步
3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

### 什么是IO多路复用？怎么实现？
IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

### select/poll/epoll三者的区别？

- ```select```：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，**开销大**），由内核根据就绪状态修改该集合的内容。（缺点2）**集合大小有限制**，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：**轮询的方式效率较低**），当文件描述符的数量增加时，效率会线性下降；
- ```poll```：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
- ```epoll```：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

总结，区别主要在于：
- 一个线程/进程所能打开的最大连接数
- 文件描述符传递方式（是否复制）
- 水平触发 or 边缘触发
- 查询就绪的描述符时的效率（是否轮询）

##### 什么时候使用select/poll，什么时候使用epoll？
当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。

##### 什么是文件描述符？
件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

内核通过文件描述符来访问文件。文件描述符指向一个文件。

##### 什么是水平触发？什么是边缘触发？
- 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；
- 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。
- 区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。
- 为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。

##### 有哪些常见的IO模型？
- 同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；
- 同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；
- IO多路复用
- 异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。

### 什么是用户态和内核态？
为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。
- 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；
- 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。
所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用**陷阱指令**，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

##### 为什么要分用户态和内核态？
- 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；
- 封装性：用户程序不需要实现更加底层的代码；
- 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。

##### 如何从用户态切换到内核态？
- 系统调用：比如读取命令行输入。本质上还是通过中断实现
- 用户程序发生异常时：比如缺页异常
- 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序


### 常见锁的种类  
1. 互斥锁与自旋锁  
互斥锁加锁失败后，线程会释放CPU，给其他线程  
自旋锁加锁失败后，线程会忙等待，直到它拿到锁  
互斥锁是一种独占锁
（待更新）

### 调度算法  
##### 进程调度算法  
    常见的调度算法：
    * 先来先服务调度算法
    * 最短作业优先调度算法
    * 高相应比优先调度算法
    * 时间片轮转调度算法
    * 最高优先级调度算法
    * 多级反馈队列调度算法
    
        1.先来先服务调度算法（FCFS）  
        最简单的调度算法，非抢占式的先来先服务（FCFS）算法  
        2. 最短作业优先调度算法（SJF）
        顾名思义，SJF算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量
        3. 高相应比优先调度算法(HRRN)  
        每次进行进程调度时，先计算**相应比优先级**，然后把相应比优先级最高的进程投入运行  
        相应比优先级的计算公式：
        优先权=（等待时间+要求服务时间）/要求服务时间  
        4. 时间片轮转调度算法（RR）  
        最古老，最简单，最公平且使用最广的算法就是时间片轮转（RR）调度算法  
        每一个进程被分配一个时间段，称为时间片，即允许该进程再该时间段中运行  
        5. 最高优先级调度算法  
        可分为：静态优先级与动态优先级、抢占式与非抢占式  
        6. 多级反馈队列调度算法  
        多级反馈队列调度算法时时间片轮转算法和最高优先级算法的综合和发展  
        *多级*表示有多个队列，每个队列的优先级从高到低，同时优先级越高时间片越短  
        *反馈*表示如果有新的进程加入优先级高的队列时，立即停止当前正在运行的进程，转而去运行优先级高的队列  


##### 内存页面置换算法  
    **缺页异常**：当CPU访问的页面不再物理内存时，便会产生一个缺页中断，请求操作系统将所缺的页调入物理内存，那它与一般中断的主要区别在于：  
    * 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令完成后检查和处理中断信号  
    * 缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一个指令执行 

    缺页中断的处理流程：  
    1. 在CPU里访问一条Load M指令，然后CPU会去找M所对应的页表项。  
    2. 如果该页表项的状态位是*有效的*，那CPU就可以直接访问物理内存，如果状态位是*无效的*，则CPU会发送缺页中断请求。
    3. 操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置  
    4. 找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但在换入前，需要在物理内存中找空闲页  
    5. 页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为*有效的*
    6. 最后，CPU重新执行导致缺页异常的指令  
    [更详细的内存页面置换算法讲解](https://www.cnblogs.com/wingsless/p/12295246.html)
    * 常见的内存页面置换算法：
    1. 最佳页面置换算法（OPT）  
    置换在*未来*最长时间不访问的页面  
    实际情况中无法实现，只是为了衡量算法效率  
    2. 先进先出置换算法（FIFO）  
    3. 最近最久未使用的置换算法（LRU）
    选择最长时间没有被访问的页面进行置换   
    虽然LRU在理论上是可以实现的，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。  
    困难的是，在每次访问内存时都必须要更新*整个链表*。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。  
    4. 时钟页面置换算法(NRU)  
    那么有没有一种既能够优化置换的次数，也能方便实现的算法呢？  
    时钟页面置换算法可以两者兼得，它和LRU近似，又是最FIFO的一种改进。  
    该算法的思路是，把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。  
    当发生缺页中断时，算法首先检查表针指向的页面：  
    * 如果他的访问位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
    * 如果访问位是1就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为0的页面为止。  
    (NRU看上面的详细讲解)  
    5. 最不常用算法  
    最不常用算法（LFU），当发生缺页中断时，选择**访问次数**最少的那个页面，并将其淘汰。  
    它的实现方式是，对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器就累加1.在发生缺页中断时，淘汰计数器值最小的那个页面。  

##### 磁盘调度算法  
    对磁盘来说，最耗费时间的是寻道时间。
    假设有这样一个请求序列，每个数字代表磁道的位置：
    98，183，37，122，14，124，65，67  
    初始磁头的位置在53磁道  

    以下的磁盘调度算法会这样操作：  
    * 先来先服务算法  
    顾名思义，先到来的请求先被服务，那么总共移动640个磁道的距离。  
    * 最短寻道时间优先  
    最短寻道时间优先算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子，会执行这样的请求：  
    65，67，37，14，98，122，124，183  
    总移动距离是236磁道，性能提高了不少  
    但这样的算法可能存在某些请求的饥饿  
    * 扫描算法  
    磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向  
    * 循环扫描算法  
    只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头。这个过程是很快的，而且返回中途不处理任何请求，该算法的特点，就是磁道只相应一个方向上的请求。  
    * LOCK与C-LOCK算法  
    （对SCAN与CSCAN算法进行优化）

## 文件系统  
(中间待补充)
* 空闲空间管理
  空闲表法  
  空闲链表法  
  位图法（用二进制位表示盘块的使用情况）  

* 文件I/O
  * 缓冲与非缓冲IO  
  * 直接与非直接IO  
  * 阻塞与非阻塞IO 同步与异步IO  


## 设备管理  

### 分页和分段有什么区别？
- 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
- 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
- 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

区别：
- 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
- 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
- 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
- 分段便于信息的保护和共享；分页的共享收到限制；
- 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

### 什么是虚拟内存？
每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。

虚拟内存的优点是让程序可以获得更多的可用内存。

##### 如何进行地址空间到物理内存的映射？
**内存管理单元**（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。

### 有哪些页面置换算法？
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
- **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
- **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
- **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
- **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
- **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
- **最不经常使用算法**NFU：置换出访问次数最少的页面

##### 局部性原理
- 时间上：最近被访问的页在不久的将来还会被访问；
- 空间上：内存中被访问的页周围的页也很可能被访问。

##### 什么是颠簸现象
颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：
- 修改页面置换算法；
- 降低同时运行的程序的数量；
- 终止该进程或增加物理内存容量。