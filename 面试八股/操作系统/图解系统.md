### 常见锁的种类  
1. 互斥锁与自旋锁  
互斥锁加锁失败后，线程会释放CPU，给其他线程  
自旋锁加锁失败后，线程会忙等待，直到它拿到锁  
互斥锁是一种独占锁
（待更新）

### 调度算法  
1. 进程调度算法  
    常见的调度算法：
    * 先来先服务调度算法
    * 最短作业优先调度算法
    * 高相应比优先调度算法
    * 时间片轮转调度算法
    * 最高优先级调度算法
    * 多级反馈队列调度算法
    
        1.先来先服务调度算法（FCFS）  
        最简单的调度算法，非抢占式的先来先服务（FCFS）算法  
        2. 最短作业优先调度算法（SJF）
        顾名思义，SJF算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量
        3. 高相应比优先调度算法(HRRN)  
        每次进行进程调度时，先计算**相应比优先级**，然后把相应比优先级最高的进程投入运行  
        相应比优先级的计算公式：
        优先权=（等待时间+要求服务时间）/要求服务时间  
        4. 时间片轮转调度算法（RR）  
        最古老，最简单，最公平且使用最广的算法就是时间片轮转（RR）调度算法  
        每一个进程被分配一个时间段，称为时间片，即允许该进程再该时间段中运行  
        5. 最高优先级调度算法  
        可分为：静态优先级与动态优先级、抢占式与非抢占式  
        6. 多级反馈队列调度算法  
        多级反馈队列调度算法时时间片轮转算法和最高优先级算法的综合和发展  
        *多级*表示有多个队列，每个队列的优先级从高到低，同时优先级越高时间片越短  
        *反馈*表示如果有新的进程加入优先级高的队列时，立即停止当前正在运行的进程，转而去运行优先级高的队列  


2. 内存页面置换算法  
    **缺页异常**：当CPU访问的页面不再物理内存时，便会产生一个缺页中断，请求操作系统将所缺的页调入物理内存，那它与一般中断的主要区别在于：  
    * 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令完成后检查和处理中断信号  
    * 缺页中断返回到该指令的开始重新执行该指令，而一般中断返回到该指令的下一个指令执行 

    缺页中断的处理流程：  
    1. 在CPU里访问一条Load M指令，然后CPU会去找M所对应的页表项。  
    2. 如果该页表项的状态位是*有效的*，那CPU就可以直接访问物理内存，如果状态位是*无效的*，则CPU会发送缺页中断请求。
    3. 操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置  
    4. 找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但在换入前，需要在物理内存中找空闲页  
    5. 页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为*有效的*
    6. 最后，CPU重新执行导致缺页异常的指令  
    [更详细的内存页面置换算法讲解](https://www.cnblogs.com/wingsless/p/12295246.html)
    * 常见的内存页面置换算法：
    1. 最佳页面置换算法（OPT）  
    置换在*未来*最长时间不访问的页面  
    实际情况中无法实现，只是为了衡量算法效率  
    2. 先进先出置换算法（FIFO）  
    3. 最近最久未使用的置换算法（LRU）
    选择最长时间没有被访问的页面进行置换   
    虽然LRU在理论上是可以实现的，但代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。  
    困难的是，在每次访问内存时都必须要更新*整个链表*。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。  
    4. 时钟页面置换算法(NRU)  
    那么有没有一种既能够优化置换的次数，也能方便实现的算法呢？  
    时钟页面置换算法可以两者兼得，它和LRU近似，又是最FIFO的一种改进。  
    该算法的思路是，把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。  
    当发生缺页中断时，算法首先检查表针指向的页面：  
    * 如果他的访问位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
    * 如果访问位是1就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为0的页面为止。  
    (NRU看上面的详细讲解)  
    5. 最不常用算法  
    最不常用算法（LFU），当发生缺页中断时，选择**访问次数**最少的那个页面，并将其淘汰。  
    它的实现方式是，对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器就累加1.在发生缺页中断时，淘汰计数器值最小的那个页面。  

3. 磁盘调度算法  
    对磁盘来说，最耗费时间的是寻道时间。
    假设有这样一个请求序列，每个数字代表磁道的位置：
    98，183，37，122，14，124，65，67  
    初始磁头的位置在53磁道  

    以下的磁盘调度算法会这样操作：  
    * 先来先服务算法  
    顾名思义，先到来的请求先被服务，那么总共移动640个磁道的距离。  
    * 最短寻道时间优先  
    最短寻道时间优先算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子，会执行这样的请求：  
    65，67，37，14，98，122，124，183  
    总移动距离是236磁道，性能提高了不少  
    但这样的算法可能存在某些请求的饥饿  
    * 扫描算法  
    磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向  
    * 循环扫描算法  
    只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头。这个过程是很快的，而且返回中途不处理任何请求，该算法的特点，就是磁道只相应一个方向上的请求。  
    * LOCK与C-LOCK算法  
    （对SCAN与CSCAN算法进行优化）

## 文件系统  
(中间待补充)
* 空闲空间管理
  空闲表法  
  空闲链表法  
  位图法（用二进制位表示盘块的使用情况）  

* 文件I/O
  * 缓冲与非缓冲IO  
  * 直接与非直接IO  
  * 阻塞与非阻塞IO 同步与异步IO  


## 设备管理  
