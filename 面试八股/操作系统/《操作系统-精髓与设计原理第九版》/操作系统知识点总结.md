### 生产者-消费者问题（小林coding图解操作系统/P137）
* 描述：
* **生产者**在生成数据之后，放在一个缓冲区中;
* **消费者**从缓冲区取出数据处理；
* 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区
  
* 使用一般信号量解决有限缓冲区生产者/消费者问题的方法：
```
/*program boundedbuffer*/
    const int sizeofbuffer = /*缓冲区大小*/
    semaphore s=1,n=0,e=sizeofbuffer;
    void producer()
    {
        while(true){
            produce();
            semWait(e);
            semwait(s);
            append();
            semSignal(s);
            semSignal(n);
        }
    }
    void consumer(){
        while(true){
            semWait(n);
            semWait(s);
            takee();
            semSignal(s);
            semSignal(e);
            consume();
        }
    }
    void main(){
        parbegin(producer,consumer);
    }

```

### 管程(P142)
*为什么使用管程？*  
——semWait和semSignal操作可能分布在整个程序中，很难看出信号量上的这些操作所产生的整体效果。

### 读者-写者问题(P150)
* 条件：
  1. 任意数量的读进程可以同时读这个文件
  2. 一次只有一个写进程可以写文件
  3. 若一个写进程正在写文件，则禁止任何读进程读文件

* 基于信号量的读者优先策略：
```
/* program readersandwriters*/
int readcount;
//x用来保证readcount被可靠更新
//wsem用来保证在有写进程写文件时，读进程不能读文件
semaphore x=1,wsem=1;

void reader()
{
    while(true){
        semWait(x);
        readcount++;
        //如果说第一个读进程卡在了semWait(wsem)这里
        //由于没有执行semSignal(x)，之后的读进程还开在semWait(x)，也就是无法读取文件
        //如果wsem=1，顺利读取，后面的读进程都可以直接进入
        if(readcount==1){
            semWait(wsem);
        }
        semSignal(x);
        READUNIT();
        semWait(x);
        readcount--;
        if(readcount==0){
            semSignal(wsem);//恢复wsem的值
        }
        semSignal(x);
    }
}

void writer()
{
    while(true){
        semWait(wsem);
        WIRTEUNIT();
        semSignal(wsem);
    }
}

void main{
    readcount=0;
    parbegin(reader,writer);
}
```

* 写者优先
  * 信号量rsem：至少有一个写进程准备访问数据区时，用于禁止所有的读进程
  * 变量writecount：控制rsem的设置
  * 信号量y：控制writecount的更新
  
```
/*program readersandwriters*/
int readcount,writecount;
semaphore x=1,y=1,z=1,wsem=1,rsem=1;

void reader()
{
    while(true){
        semWait(z);
            semWait(rsem);
                semWait(x);
                    readcount++;
                    if(readcount==1){
                        semWait(wsem);
                    }
                semSignal(x);
            semSignal(rsem);
        semSignal(z);
        READUNIT();
        semWait(x);
            readcount--;
            if(readcount==0){
                semSignal(wsem);
            }
        semSignal(x);
    }
}

void writer(){
    while(true){
        semWait(y);
            writecount++;
            if(writecount==1){
                semWait(rsem);
            }
        semSignal(y);
        semWait(wsem);
        WRITEUNIT();
        semSignal(wsem);
        semWait(y);
            writecount--;
            if(writecount==0){
                semSignal(rsem);
            }
        semSignal(y);
    }
}

void main(){
    readcount=writecount=0;
    parbegin(reader,writer);
}
```

* 公平策略（待更新）

### 哲学家就餐问题(P176)
* （书。待更新）
1. 基于信号量的解决方案：
2. 基于管程的解决方案：

* 小林coding
  * 方案1：  
  每个哲学家都先拿左边的叉子，再拿右边的叉子。  
  这样会导致死锁，即每个哲学家都拿到了左边的叉子，却无法永远拿到右边的叉子。
  * 方案2：  
  同时只允许一个哲学家拿叉子并吃饭  
  这样显然不会出现死锁，但效率太低了
  * 方案3：  
  让**偶数**编号的哲学家**先拿左边的叉子后拿右边的叉子**  
  让**奇数**编号的哲学家**先拿右边的叉子后拿左边的叉子**
  * 方案4： 
  用一个数组state记录每一位哲学家在进程、思考还是饥饿状态（正在试图拿叉子）。  
  那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态


### 并发：死锁和饥饿
1. 死锁原理  
（表面上看）联合进程图有重叠
   * 可重用资源：给系统设计施加关于资源请求顺序的约束、使用虚存  
   * 可消耗资源
   1. **通常有三种处理死锁的方法：**
   * **死锁预防**：不允许死锁产生的三个必要条件成立  
   * **死锁避免**：若此次分配可能产生死锁，就不满足该资源请求
   * **死锁检测**
   2. 死锁的条件  
   死锁有三个必要条件：  
   * 互斥：一次只有一个进程可以使用一个资源  
   * 占有且等待：当一个进程等待其他进程时，继续占有已经分配的资源 
   * 不可抢占：不能强行抢占其他进程已占有的资源  
   此外，要产生死锁，还需要第四个条件：  
   * 循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源  
   3. 死锁预防
   简单来讲，死锁预防策略是试图设计一种系统来排除发生死锁的可能性。死锁预防方法分为两类。一类是间接死锁预防方法


  
